{"ast":null,"code":"'use strict';\n\nvar utils = require('./../utils');\n\nvar settle = require('./../core/settle');\n\nvar buildFullPath = require('../core/buildFullPath');\n\nvar buildURL = require('./../helpers/buildURL');\n\nvar http = require('http');\n\nvar https = require('https');\n\nvar httpFollow = require('follow-redirects').http;\n\nvar httpsFollow = require('follow-redirects').https;\n\nvar url = require('url');\n\nvar zlib = require('zlib');\n\nvar VERSION = require('./../env/data').version;\n\nvar transitionalDefaults = require('../defaults/transitional');\n\nvar AxiosError = require('../core/AxiosError');\n\nvar CanceledError = require('../cancel/CanceledError');\n\nvar isHttps = /https:?/;\nvar supportedProtocols = ['http:', 'https:', 'file:'];\n/**\n *\n * @param {http.ClientRequestArgs} options\n * @param {AxiosProxyConfig} proxy\n * @param {string} location\n */\n\nfunction setProxy(options, proxy, location) {\n  options.hostname = proxy.host;\n  options.host = proxy.host;\n  options.port = proxy.port;\n  options.path = location; // Basic proxy authorization\n\n  if (proxy.auth) {\n    var base64 = Buffer.from(proxy.auth.username + ':' + proxy.auth.password, 'utf8').toString('base64');\n    options.headers['Proxy-Authorization'] = 'Basic ' + base64;\n  } // If a proxy is used, any redirects must also pass through the proxy\n\n\n  options.beforeRedirect = function beforeRedirect(redirection) {\n    redirection.headers.host = redirection.host;\n    setProxy(redirection, proxy, redirection.href);\n  };\n}\n/*eslint consistent-return:0*/\n\n\nmodule.exports = function httpAdapter(config) {\n  return new Promise(function dispatchHttpRequest(resolvePromise, rejectPromise) {\n    var onCanceled;\n\n    function done() {\n      if (config.cancelToken) {\n        config.cancelToken.unsubscribe(onCanceled);\n      }\n\n      if (config.signal) {\n        config.signal.removeEventListener('abort', onCanceled);\n      }\n    }\n\n    var resolve = function resolve(value) {\n      done();\n      resolvePromise(value);\n    };\n\n    var rejected = false;\n\n    var reject = function reject(value) {\n      done();\n      rejected = true;\n      rejectPromise(value);\n    };\n\n    var data = config.data;\n    var headers = config.headers;\n    var headerNames = {};\n    Object.keys(headers).forEach(function storeLowerName(name) {\n      headerNames[name.toLowerCase()] = name;\n    }); // Set User-Agent (required by some servers)\n    // See https://github.com/axios/axios/issues/69\n\n    if ('user-agent' in headerNames) {\n      // User-Agent is specified; handle case where no UA header is desired\n      if (!headers[headerNames['user-agent']]) {\n        delete headers[headerNames['user-agent']];\n      } // Otherwise, use specified value\n\n    } else {\n      // Only set header if it hasn't been set in config\n      headers['User-Agent'] = 'axios/' + VERSION;\n    } // support for https://www.npmjs.com/package/form-data api\n\n\n    if (utils.isFormData(data) && utils.isFunction(data.getHeaders)) {\n      Object.assign(headers, data.getHeaders());\n    } else if (data && !utils.isStream(data)) {\n      if (Buffer.isBuffer(data)) {// Nothing to do...\n      } else if (utils.isArrayBuffer(data)) {\n        data = Buffer.from(new Uint8Array(data));\n      } else if (utils.isString(data)) {\n        data = Buffer.from(data, 'utf-8');\n      } else {\n        return reject(new AxiosError('Data after transformation must be a string, an ArrayBuffer, a Buffer, or a Stream', AxiosError.ERR_BAD_REQUEST, config));\n      }\n\n      if (config.maxBodyLength > -1 && data.length > config.maxBodyLength) {\n        return reject(new AxiosError('Request body larger than maxBodyLength limit', AxiosError.ERR_BAD_REQUEST, config));\n      } // Add Content-Length header if data exists\n\n\n      if (!headerNames['content-length']) {\n        headers['Content-Length'] = data.length;\n      }\n    } // HTTP basic authentication\n\n\n    var auth = undefined;\n\n    if (config.auth) {\n      var username = config.auth.username || '';\n      var password = config.auth.password || '';\n      auth = username + ':' + password;\n    } // Parse url\n\n\n    var fullPath = buildFullPath(config.baseURL, config.url);\n    var parsed = url.parse(fullPath);\n    var protocol = parsed.protocol || supportedProtocols[0];\n\n    if (supportedProtocols.indexOf(protocol) === -1) {\n      return reject(new AxiosError('Unsupported protocol ' + protocol, AxiosError.ERR_BAD_REQUEST, config));\n    }\n\n    if (!auth && parsed.auth) {\n      var urlAuth = parsed.auth.split(':');\n      var urlUsername = urlAuth[0] || '';\n      var urlPassword = urlAuth[1] || '';\n      auth = urlUsername + ':' + urlPassword;\n    }\n\n    if (auth && headerNames.authorization) {\n      delete headers[headerNames.authorization];\n    }\n\n    var isHttpsRequest = isHttps.test(protocol);\n    var agent = isHttpsRequest ? config.httpsAgent : config.httpAgent;\n\n    try {\n      buildURL(parsed.path, config.params, config.paramsSerializer).replace(/^\\?/, '');\n    } catch (err) {\n      var customErr = new Error(err.message);\n      customErr.config = config;\n      customErr.url = config.url;\n      customErr.exists = true;\n      reject(customErr);\n    }\n\n    var options = {\n      path: buildURL(parsed.path, config.params, config.paramsSerializer).replace(/^\\?/, ''),\n      method: config.method.toUpperCase(),\n      headers: headers,\n      agent: agent,\n      agents: {\n        http: config.httpAgent,\n        https: config.httpsAgent\n      },\n      auth: auth\n    };\n\n    if (config.socketPath) {\n      options.socketPath = config.socketPath;\n    } else {\n      options.hostname = parsed.hostname;\n      options.port = parsed.port;\n    }\n\n    var proxy = config.proxy;\n\n    if (!proxy && proxy !== false) {\n      var proxyEnv = protocol.slice(0, -1) + '_proxy';\n      var proxyUrl = process.env[proxyEnv] || process.env[proxyEnv.toUpperCase()];\n\n      if (proxyUrl) {\n        var parsedProxyUrl = url.parse(proxyUrl);\n        var noProxyEnv = process.env.no_proxy || process.env.NO_PROXY;\n        var shouldProxy = true;\n\n        if (noProxyEnv) {\n          var noProxy = noProxyEnv.split(',').map(function trim(s) {\n            return s.trim();\n          });\n          shouldProxy = !noProxy.some(function proxyMatch(proxyElement) {\n            if (!proxyElement) {\n              return false;\n            }\n\n            if (proxyElement === '*') {\n              return true;\n            }\n\n            if (proxyElement[0] === '.' && parsed.hostname.substr(parsed.hostname.length - proxyElement.length) === proxyElement) {\n              return true;\n            }\n\n            return parsed.hostname === proxyElement;\n          });\n        }\n\n        if (shouldProxy) {\n          proxy = {\n            host: parsedProxyUrl.hostname,\n            port: parsedProxyUrl.port,\n            protocol: parsedProxyUrl.protocol\n          };\n\n          if (parsedProxyUrl.auth) {\n            var proxyUrlAuth = parsedProxyUrl.auth.split(':');\n            proxy.auth = {\n              username: proxyUrlAuth[0],\n              password: proxyUrlAuth[1]\n            };\n          }\n        }\n      }\n    }\n\n    if (proxy) {\n      options.headers.host = parsed.hostname + (parsed.port ? ':' + parsed.port : '');\n      setProxy(options, proxy, protocol + '//' + parsed.hostname + (parsed.port ? ':' + parsed.port : '') + options.path);\n    }\n\n    var transport;\n    var isHttpsProxy = isHttpsRequest && (proxy ? isHttps.test(proxy.protocol) : true);\n\n    if (config.transport) {\n      transport = config.transport;\n    } else if (config.maxRedirects === 0) {\n      transport = isHttpsProxy ? https : http;\n    } else {\n      if (config.maxRedirects) {\n        options.maxRedirects = config.maxRedirects;\n      }\n\n      if (config.beforeRedirect) {\n        options.beforeRedirect = config.beforeRedirect;\n      }\n\n      transport = isHttpsProxy ? httpsFollow : httpFollow;\n    }\n\n    if (config.maxBodyLength > -1) {\n      options.maxBodyLength = config.maxBodyLength;\n    }\n\n    if (config.insecureHTTPParser) {\n      options.insecureHTTPParser = config.insecureHTTPParser;\n    } // Create the request\n\n\n    var req = transport.request(options, function handleResponse(res) {\n      if (req.aborted) return; // uncompress the response body transparently if required\n\n      var stream = res; // return the last request in case of redirects\n\n      var lastRequest = res.req || req; // if no content, is HEAD request or decompress disabled we should not decompress\n\n      if (res.statusCode !== 204 && lastRequest.method !== 'HEAD' && config.decompress !== false) {\n        switch (res.headers['content-encoding']) {\n          /*eslint default-case:0*/\n          case 'gzip':\n          case 'compress':\n          case 'deflate':\n            // add the unzipper to the body stream processing pipeline\n            stream = stream.pipe(zlib.createUnzip()); // remove the content-encoding in order to not confuse downstream operations\n\n            delete res.headers['content-encoding'];\n            break;\n        }\n      }\n\n      var response = {\n        status: res.statusCode,\n        statusText: res.statusMessage,\n        headers: res.headers,\n        config: config,\n        request: lastRequest\n      };\n\n      if (config.responseType === 'stream') {\n        response.data = stream;\n        settle(resolve, reject, response);\n      } else {\n        var responseBuffer = [];\n        var totalResponseBytes = 0;\n        stream.on('data', function handleStreamData(chunk) {\n          responseBuffer.push(chunk);\n          totalResponseBytes += chunk.length; // make sure the content length is not over the maxContentLength if specified\n\n          if (config.maxContentLength > -1 && totalResponseBytes > config.maxContentLength) {\n            // stream.destoy() emit aborted event before calling reject() on Node.js v16\n            rejected = true;\n            stream.destroy();\n            reject(new AxiosError('maxContentLength size of ' + config.maxContentLength + ' exceeded', AxiosError.ERR_BAD_RESPONSE, config, lastRequest));\n          }\n        });\n        stream.on('aborted', function handlerStreamAborted() {\n          if (rejected) {\n            return;\n          }\n\n          stream.destroy();\n          reject(new AxiosError('maxContentLength size of ' + config.maxContentLength + ' exceeded', AxiosError.ERR_BAD_RESPONSE, config, lastRequest));\n        });\n        stream.on('error', function handleStreamError(err) {\n          if (req.aborted) return;\n          reject(AxiosError.from(err, null, config, lastRequest));\n        });\n        stream.on('end', function handleStreamEnd() {\n          try {\n            var responseData = responseBuffer.length === 1 ? responseBuffer[0] : Buffer.concat(responseBuffer);\n\n            if (config.responseType !== 'arraybuffer') {\n              responseData = responseData.toString(config.responseEncoding);\n\n              if (!config.responseEncoding || config.responseEncoding === 'utf8') {\n                responseData = utils.stripBOM(responseData);\n              }\n            }\n\n            response.data = responseData;\n          } catch (err) {\n            reject(AxiosError.from(err, null, config, response.request, response));\n          }\n\n          settle(resolve, reject, response);\n        });\n      }\n    }); // Handle errors\n\n    req.on('error', function handleRequestError(err) {\n      // @todo remove\n      // if (req.aborted && err.code !== AxiosError.ERR_FR_TOO_MANY_REDIRECTS) return;\n      reject(AxiosError.from(err, null, config, req));\n    }); // set tcp keep alive to prevent drop connection by peer\n\n    req.on('socket', function handleRequestSocket(socket) {\n      // default interval of sending ack packet is 1 minute\n      socket.setKeepAlive(true, 1000 * 60);\n    }); // Handle request timeout\n\n    if (config.timeout) {\n      // This is forcing a int timeout to avoid problems if the `req` interface doesn't handle other types.\n      var timeout = parseInt(config.timeout, 10);\n\n      if (isNaN(timeout)) {\n        reject(new AxiosError('error trying to parse `config.timeout` to int', AxiosError.ERR_BAD_OPTION_VALUE, config, req));\n        return;\n      } // Sometime, the response will be very slow, and does not respond, the connect event will be block by event loop system.\n      // And timer callback will be fired, and abort() will be invoked before connection, then get \"socket hang up\" and code ECONNRESET.\n      // At this time, if we have a large number of request, nodejs will hang up some socket on background. and the number will up and up.\n      // And then these socket which be hang up will devoring CPU little by little.\n      // ClientRequest.setTimeout will be fired on the specify milliseconds, and can make sure that abort() will be fired after connect.\n\n\n      req.setTimeout(timeout, function handleRequestTimeout() {\n        req.abort();\n        var transitional = config.transitional || transitionalDefaults;\n        reject(new AxiosError('timeout of ' + timeout + 'ms exceeded', transitional.clarifyTimeoutError ? AxiosError.ETIMEDOUT : AxiosError.ECONNABORTED, config, req));\n      });\n    }\n\n    if (config.cancelToken || config.signal) {\n      // Handle cancellation\n      // eslint-disable-next-line func-names\n      onCanceled = function (cancel) {\n        if (req.aborted) return;\n        req.abort();\n        reject(!cancel || cancel && cancel.type ? new CanceledError() : cancel);\n      };\n\n      config.cancelToken && config.cancelToken.subscribe(onCanceled);\n\n      if (config.signal) {\n        config.signal.aborted ? onCanceled() : config.signal.addEventListener('abort', onCanceled);\n      }\n    } // Send the request\n\n\n    if (utils.isStream(data)) {\n      data.on('error', function handleStreamError(err) {\n        reject(AxiosError.from(err, config, null, req));\n      }).pipe(req);\n    } else {\n      req.end(data);\n    }\n  });\n};","map":{"version":3,"names":["utils","require","settle","buildFullPath","buildURL","http","https","httpFollow","httpsFollow","url","zlib","VERSION","version","transitionalDefaults","AxiosError","CanceledError","isHttps","supportedProtocols","setProxy","options","proxy","location","hostname","host","port","path","auth","base64","Buffer","from","username","password","toString","headers","beforeRedirect","redirection","href","module","exports","httpAdapter","config","Promise","dispatchHttpRequest","resolvePromise","rejectPromise","onCanceled","done","cancelToken","unsubscribe","signal","removeEventListener","resolve","value","rejected","reject","data","headerNames","Object","keys","forEach","storeLowerName","name","toLowerCase","isFormData","isFunction","getHeaders","assign","isStream","isBuffer","isArrayBuffer","Uint8Array","isString","ERR_BAD_REQUEST","maxBodyLength","length","undefined","fullPath","baseURL","parsed","parse","protocol","indexOf","urlAuth","split","urlUsername","urlPassword","authorization","isHttpsRequest","test","agent","httpsAgent","httpAgent","params","paramsSerializer","replace","err","customErr","Error","message","exists","method","toUpperCase","agents","socketPath","proxyEnv","slice","proxyUrl","process","env","parsedProxyUrl","noProxyEnv","no_proxy","NO_PROXY","shouldProxy","noProxy","map","trim","s","some","proxyMatch","proxyElement","substr","proxyUrlAuth","transport","isHttpsProxy","maxRedirects","insecureHTTPParser","req","request","handleResponse","res","aborted","stream","lastRequest","statusCode","decompress","pipe","createUnzip","response","status","statusText","statusMessage","responseType","responseBuffer","totalResponseBytes","on","handleStreamData","chunk","push","maxContentLength","destroy","ERR_BAD_RESPONSE","handlerStreamAborted","handleStreamError","handleStreamEnd","responseData","concat","responseEncoding","stripBOM","handleRequestError","handleRequestSocket","socket","setKeepAlive","timeout","parseInt","isNaN","ERR_BAD_OPTION_VALUE","setTimeout","handleRequestTimeout","abort","transitional","clarifyTimeoutError","ETIMEDOUT","ECONNABORTED","cancel","type","subscribe","addEventListener","end"],"sources":["C:/Users/HP/OneDrive/UCSC/Third Year/SCS3214/Project/BloodCare/web_client/node_modules/axios/lib/adapters/http.js"],"sourcesContent":["'use strict';\n\nvar utils = require('./../utils');\nvar settle = require('./../core/settle');\nvar buildFullPath = require('../core/buildFullPath');\nvar buildURL = require('./../helpers/buildURL');\nvar http = require('http');\nvar https = require('https');\nvar httpFollow = require('follow-redirects').http;\nvar httpsFollow = require('follow-redirects').https;\nvar url = require('url');\nvar zlib = require('zlib');\nvar VERSION = require('./../env/data').version;\nvar transitionalDefaults = require('../defaults/transitional');\nvar AxiosError = require('../core/AxiosError');\nvar CanceledError = require('../cancel/CanceledError');\n\nvar isHttps = /https:?/;\n\nvar supportedProtocols = [ 'http:', 'https:', 'file:' ];\n\n/**\n *\n * @param {http.ClientRequestArgs} options\n * @param {AxiosProxyConfig} proxy\n * @param {string} location\n */\nfunction setProxy(options, proxy, location) {\n  options.hostname = proxy.host;\n  options.host = proxy.host;\n  options.port = proxy.port;\n  options.path = location;\n\n  // Basic proxy authorization\n  if (proxy.auth) {\n    var base64 = Buffer.from(proxy.auth.username + ':' + proxy.auth.password, 'utf8').toString('base64');\n    options.headers['Proxy-Authorization'] = 'Basic ' + base64;\n  }\n\n  // If a proxy is used, any redirects must also pass through the proxy\n  options.beforeRedirect = function beforeRedirect(redirection) {\n    redirection.headers.host = redirection.host;\n    setProxy(redirection, proxy, redirection.href);\n  };\n}\n\n/*eslint consistent-return:0*/\nmodule.exports = function httpAdapter(config) {\n  return new Promise(function dispatchHttpRequest(resolvePromise, rejectPromise) {\n    var onCanceled;\n    function done() {\n      if (config.cancelToken) {\n        config.cancelToken.unsubscribe(onCanceled);\n      }\n\n      if (config.signal) {\n        config.signal.removeEventListener('abort', onCanceled);\n      }\n    }\n    var resolve = function resolve(value) {\n      done();\n      resolvePromise(value);\n    };\n    var rejected = false;\n    var reject = function reject(value) {\n      done();\n      rejected = true;\n      rejectPromise(value);\n    };\n    var data = config.data;\n    var headers = config.headers;\n    var headerNames = {};\n\n    Object.keys(headers).forEach(function storeLowerName(name) {\n      headerNames[name.toLowerCase()] = name;\n    });\n\n    // Set User-Agent (required by some servers)\n    // See https://github.com/axios/axios/issues/69\n    if ('user-agent' in headerNames) {\n      // User-Agent is specified; handle case where no UA header is desired\n      if (!headers[headerNames['user-agent']]) {\n        delete headers[headerNames['user-agent']];\n      }\n      // Otherwise, use specified value\n    } else {\n      // Only set header if it hasn't been set in config\n      headers['User-Agent'] = 'axios/' + VERSION;\n    }\n\n    // support for https://www.npmjs.com/package/form-data api\n    if (utils.isFormData(data) && utils.isFunction(data.getHeaders)) {\n      Object.assign(headers, data.getHeaders());\n    } else if (data && !utils.isStream(data)) {\n      if (Buffer.isBuffer(data)) {\n        // Nothing to do...\n      } else if (utils.isArrayBuffer(data)) {\n        data = Buffer.from(new Uint8Array(data));\n      } else if (utils.isString(data)) {\n        data = Buffer.from(data, 'utf-8');\n      } else {\n        return reject(new AxiosError(\n          'Data after transformation must be a string, an ArrayBuffer, a Buffer, or a Stream',\n          AxiosError.ERR_BAD_REQUEST,\n          config\n        ));\n      }\n\n      if (config.maxBodyLength > -1 && data.length > config.maxBodyLength) {\n        return reject(new AxiosError(\n          'Request body larger than maxBodyLength limit',\n          AxiosError.ERR_BAD_REQUEST,\n          config\n        ));\n      }\n\n      // Add Content-Length header if data exists\n      if (!headerNames['content-length']) {\n        headers['Content-Length'] = data.length;\n      }\n    }\n\n    // HTTP basic authentication\n    var auth = undefined;\n    if (config.auth) {\n      var username = config.auth.username || '';\n      var password = config.auth.password || '';\n      auth = username + ':' + password;\n    }\n\n    // Parse url\n    var fullPath = buildFullPath(config.baseURL, config.url);\n    var parsed = url.parse(fullPath);\n    var protocol = parsed.protocol || supportedProtocols[0];\n\n    if (supportedProtocols.indexOf(protocol) === -1) {\n      return reject(new AxiosError(\n        'Unsupported protocol ' + protocol,\n        AxiosError.ERR_BAD_REQUEST,\n        config\n      ));\n    }\n\n    if (!auth && parsed.auth) {\n      var urlAuth = parsed.auth.split(':');\n      var urlUsername = urlAuth[0] || '';\n      var urlPassword = urlAuth[1] || '';\n      auth = urlUsername + ':' + urlPassword;\n    }\n\n    if (auth && headerNames.authorization) {\n      delete headers[headerNames.authorization];\n    }\n\n    var isHttpsRequest = isHttps.test(protocol);\n    var agent = isHttpsRequest ? config.httpsAgent : config.httpAgent;\n\n    try {\n      buildURL(parsed.path, config.params, config.paramsSerializer).replace(/^\\?/, '');\n    } catch (err) {\n      var customErr = new Error(err.message);\n      customErr.config = config;\n      customErr.url = config.url;\n      customErr.exists = true;\n      reject(customErr);\n    }\n\n    var options = {\n      path: buildURL(parsed.path, config.params, config.paramsSerializer).replace(/^\\?/, ''),\n      method: config.method.toUpperCase(),\n      headers: headers,\n      agent: agent,\n      agents: { http: config.httpAgent, https: config.httpsAgent },\n      auth: auth\n    };\n\n    if (config.socketPath) {\n      options.socketPath = config.socketPath;\n    } else {\n      options.hostname = parsed.hostname;\n      options.port = parsed.port;\n    }\n\n    var proxy = config.proxy;\n    if (!proxy && proxy !== false) {\n      var proxyEnv = protocol.slice(0, -1) + '_proxy';\n      var proxyUrl = process.env[proxyEnv] || process.env[proxyEnv.toUpperCase()];\n      if (proxyUrl) {\n        var parsedProxyUrl = url.parse(proxyUrl);\n        var noProxyEnv = process.env.no_proxy || process.env.NO_PROXY;\n        var shouldProxy = true;\n\n        if (noProxyEnv) {\n          var noProxy = noProxyEnv.split(',').map(function trim(s) {\n            return s.trim();\n          });\n\n          shouldProxy = !noProxy.some(function proxyMatch(proxyElement) {\n            if (!proxyElement) {\n              return false;\n            }\n            if (proxyElement === '*') {\n              return true;\n            }\n            if (proxyElement[0] === '.' &&\n                parsed.hostname.substr(parsed.hostname.length - proxyElement.length) === proxyElement) {\n              return true;\n            }\n\n            return parsed.hostname === proxyElement;\n          });\n        }\n\n        if (shouldProxy) {\n          proxy = {\n            host: parsedProxyUrl.hostname,\n            port: parsedProxyUrl.port,\n            protocol: parsedProxyUrl.protocol\n          };\n\n          if (parsedProxyUrl.auth) {\n            var proxyUrlAuth = parsedProxyUrl.auth.split(':');\n            proxy.auth = {\n              username: proxyUrlAuth[0],\n              password: proxyUrlAuth[1]\n            };\n          }\n        }\n      }\n    }\n\n    if (proxy) {\n      options.headers.host = parsed.hostname + (parsed.port ? ':' + parsed.port : '');\n      setProxy(options, proxy, protocol + '//' + parsed.hostname + (parsed.port ? ':' + parsed.port : '') + options.path);\n    }\n\n    var transport;\n    var isHttpsProxy = isHttpsRequest && (proxy ? isHttps.test(proxy.protocol) : true);\n    if (config.transport) {\n      transport = config.transport;\n    } else if (config.maxRedirects === 0) {\n      transport = isHttpsProxy ? https : http;\n    } else {\n      if (config.maxRedirects) {\n        options.maxRedirects = config.maxRedirects;\n      }\n      if (config.beforeRedirect) {\n        options.beforeRedirect = config.beforeRedirect;\n      }\n      transport = isHttpsProxy ? httpsFollow : httpFollow;\n    }\n\n    if (config.maxBodyLength > -1) {\n      options.maxBodyLength = config.maxBodyLength;\n    }\n\n    if (config.insecureHTTPParser) {\n      options.insecureHTTPParser = config.insecureHTTPParser;\n    }\n\n    // Create the request\n    var req = transport.request(options, function handleResponse(res) {\n      if (req.aborted) return;\n\n      // uncompress the response body transparently if required\n      var stream = res;\n\n      // return the last request in case of redirects\n      var lastRequest = res.req || req;\n\n\n      // if no content, is HEAD request or decompress disabled we should not decompress\n      if (res.statusCode !== 204 && lastRequest.method !== 'HEAD' && config.decompress !== false) {\n        switch (res.headers['content-encoding']) {\n        /*eslint default-case:0*/\n        case 'gzip':\n        case 'compress':\n        case 'deflate':\n        // add the unzipper to the body stream processing pipeline\n          stream = stream.pipe(zlib.createUnzip());\n\n          // remove the content-encoding in order to not confuse downstream operations\n          delete res.headers['content-encoding'];\n          break;\n        }\n      }\n\n      var response = {\n        status: res.statusCode,\n        statusText: res.statusMessage,\n        headers: res.headers,\n        config: config,\n        request: lastRequest\n      };\n\n      if (config.responseType === 'stream') {\n        response.data = stream;\n        settle(resolve, reject, response);\n      } else {\n        var responseBuffer = [];\n        var totalResponseBytes = 0;\n        stream.on('data', function handleStreamData(chunk) {\n          responseBuffer.push(chunk);\n          totalResponseBytes += chunk.length;\n\n          // make sure the content length is not over the maxContentLength if specified\n          if (config.maxContentLength > -1 && totalResponseBytes > config.maxContentLength) {\n            // stream.destoy() emit aborted event before calling reject() on Node.js v16\n            rejected = true;\n            stream.destroy();\n            reject(new AxiosError('maxContentLength size of ' + config.maxContentLength + ' exceeded',\n              AxiosError.ERR_BAD_RESPONSE, config, lastRequest));\n          }\n        });\n\n        stream.on('aborted', function handlerStreamAborted() {\n          if (rejected) {\n            return;\n          }\n          stream.destroy();\n          reject(new AxiosError(\n            'maxContentLength size of ' + config.maxContentLength + ' exceeded',\n            AxiosError.ERR_BAD_RESPONSE,\n            config,\n            lastRequest\n          ));\n        });\n\n        stream.on('error', function handleStreamError(err) {\n          if (req.aborted) return;\n          reject(AxiosError.from(err, null, config, lastRequest));\n        });\n\n        stream.on('end', function handleStreamEnd() {\n          try {\n            var responseData = responseBuffer.length === 1 ? responseBuffer[0] : Buffer.concat(responseBuffer);\n            if (config.responseType !== 'arraybuffer') {\n              responseData = responseData.toString(config.responseEncoding);\n              if (!config.responseEncoding || config.responseEncoding === 'utf8') {\n                responseData = utils.stripBOM(responseData);\n              }\n            }\n            response.data = responseData;\n          } catch (err) {\n            reject(AxiosError.from(err, null, config, response.request, response));\n          }\n          settle(resolve, reject, response);\n        });\n      }\n    });\n\n    // Handle errors\n    req.on('error', function handleRequestError(err) {\n      // @todo remove\n      // if (req.aborted && err.code !== AxiosError.ERR_FR_TOO_MANY_REDIRECTS) return;\n      reject(AxiosError.from(err, null, config, req));\n    });\n\n    // set tcp keep alive to prevent drop connection by peer\n    req.on('socket', function handleRequestSocket(socket) {\n      // default interval of sending ack packet is 1 minute\n      socket.setKeepAlive(true, 1000 * 60);\n    });\n\n    // Handle request timeout\n    if (config.timeout) {\n      // This is forcing a int timeout to avoid problems if the `req` interface doesn't handle other types.\n      var timeout = parseInt(config.timeout, 10);\n\n      if (isNaN(timeout)) {\n        reject(new AxiosError(\n          'error trying to parse `config.timeout` to int',\n          AxiosError.ERR_BAD_OPTION_VALUE,\n          config,\n          req\n        ));\n\n        return;\n      }\n\n      // Sometime, the response will be very slow, and does not respond, the connect event will be block by event loop system.\n      // And timer callback will be fired, and abort() will be invoked before connection, then get \"socket hang up\" and code ECONNRESET.\n      // At this time, if we have a large number of request, nodejs will hang up some socket on background. and the number will up and up.\n      // And then these socket which be hang up will devoring CPU little by little.\n      // ClientRequest.setTimeout will be fired on the specify milliseconds, and can make sure that abort() will be fired after connect.\n      req.setTimeout(timeout, function handleRequestTimeout() {\n        req.abort();\n        var transitional = config.transitional || transitionalDefaults;\n        reject(new AxiosError(\n          'timeout of ' + timeout + 'ms exceeded',\n          transitional.clarifyTimeoutError ? AxiosError.ETIMEDOUT : AxiosError.ECONNABORTED,\n          config,\n          req\n        ));\n      });\n    }\n\n    if (config.cancelToken || config.signal) {\n      // Handle cancellation\n      // eslint-disable-next-line func-names\n      onCanceled = function(cancel) {\n        if (req.aborted) return;\n\n        req.abort();\n        reject(!cancel || (cancel && cancel.type) ? new CanceledError() : cancel);\n      };\n\n      config.cancelToken && config.cancelToken.subscribe(onCanceled);\n      if (config.signal) {\n        config.signal.aborted ? onCanceled() : config.signal.addEventListener('abort', onCanceled);\n      }\n    }\n\n\n    // Send the request\n    if (utils.isStream(data)) {\n      data.on('error', function handleStreamError(err) {\n        reject(AxiosError.from(err, config, null, req));\n      }).pipe(req);\n    } else {\n      req.end(data);\n    }\n  });\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}